with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Integer_Text_IO;    use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with Piles;

Package body arbre_binaire is
   Package Piles_Arbre is
     new Piles(T_Element => T_Arbre_Binaire);
   use Piles_Arbre;


    procedure Free is
		new Ada.Unchecked_Deallocation (Object => T_Cellule_Arbre, Name => T_Arbre_Binaire);


    Procedure Initialiser_Arbre (A: out T_Arbre_Binaire;Cle : in T_Cle) is
    begin
      A := New T_Cellule_Arbre;
      --arbre n'est pas nulle à l'initialisation.
      A.all.gauche := Null;
      A.all.droite := Null;
      A.all.Cle := Cle;
   end Initialiser_Arbre;

    procedure Detruire_arbre(A: in out T_Arbre_Binaire) is
    begin
        if A = Null then
            Null;

        else
            detruire_arbre(A.all.gauche);
            detruire_arbre(A.all.droite);
            Free(A);
        end if;
    end Detruire_arbre;




    procedure Ajouter(A: in out T_Arbre_Binaire; Cle_parent: in T_Cle; Cle_enfant: in T_Cle; choix: in Boolean) is
      P: T_Pile;
      A1 : T_Arbre_Binaire;
   begin
         Empiler(P,A);

         if A.all.gauche /= Null or A.all.Cle /= Cle_Enfant then
            A := A.all.gauche;
            Empiler(P,A);
         else
            null;

         end if;
      A1:=sommet(P);
         while A1.all.droite /= Null loop
            depiler(P);
            A1:=sommet(P);
         end loop;
         if not Est_Vide(P) and A.all.Cle /= Cle_Enfant then
            A:=A1;
            Ajouter(A,Cle_parent,Cle_enfant,choix);
         elsif A.all.CLe = Cle_Enfant then
            if choix then
               A.all.gauche.all.Cle := Cle_parent;
            else
            A.all.droite.all.Cle := Cle_parent;
            end if;
         else
            raise Est_Absent_Cle;
         end if;


      end Ajouter;

      procedure chercher_noeud (A: in out T_Arbre_Binaire; Noeud : in out T_Arbre_binaire; Cle : in T_Cle) is
         A1 : T_Arbre_Binaire;
         P: T_Pile;
      begin
         Empiler(P,A);

         if A.all.gauche /= Null or A.all.Cle /= Cle then
            A := A.all.gauche;
            Empiler(P,A);
         else
            null;

      end if;
      A1:=sommet(P);
         while A1.all.droite /= Null loop
            depiler(P);
            A1:=sommet(P);
         end loop;
         if not Est_Vide(P) and A.all.Cle /= Cle then
            A:=A1;
            chercher_noeud(A,Noeud,Cle);
         elsif A.all.CLe = Cle then
            Noeud := A;
         else
            raise Est_Absent_Cle;
      end if;
      end chercher_noeud;






    procedure Afficher_Arbre (A : in T_Arbre_Binaire) is
    begin
        if A = Null then
            Null;

        else
            Afficher_Arbre(A.all.gauche);
            Put(" Cle : ");
            Afficher(A.all.Cle);
            New_Line;
            Afficher_Arbre(A.all.droite);
        end if;
    end Afficher_Arbre;




    procedure Supprimer_Noeud(A : in out T_Arbre_Binaire; Cle : in T_Cle) is
            A_detruire : T_Arbre_Binaire;
            Noeud :  T_Arbre_Binaire;
         begin
            chercher_noeud(A,Noeud,Cle);
            detruire_arbre(Noeud);
         end Supprimer_Noeud;







   function Est_Present(A: in out T_Arbre_Binaire; Cle: in T_Cle) return boolean is
      Noeud : T_Arbre_Binaire;
      b : boolean;
      procedure test_exception (A: in out T_Arbre_Binaire; Cle: in T_Cle; b:out boolean) is
      begin
         chercher_noeud(A,Noeud,Cle);
      exception
         when Est_Absent_Cle => b := True;
      end test_exception;

   begin
      test_exception(A,Cle,b);

      return b;
    end Est_present;






    function gauche (A : in T_Arbre_Binaire) return T_Arbre_Binaire is
    begin
        return A.all.gauche;
    end gauche;

    function Droite (A: in T_Arbre_Binaire) return T_Arbre_Binaire is
    begin
        return A.all.droite;
    end droite;

    function Obtenir_Cle (A: in T_Arbre_Binaire) return T_Cle is
    begin
        return A.all.Cle;
    end Obtenir_Cle;
    procedure egal (A1: out T_Arbre_Binaire ; A2: in T_Arbre_Binaire) is
    begin
        A1 := A2;
    end egal;

    function Est_egal (A1: in T_Arbre_Binaire; A2: in T_Arbre_Binaire) return Boolean is
    begin
        return (A1 = A2);
    end Est_egal;

    function est_egal_null (A1: in T_Arbre_Binaire) return Boolean is
    begin
        return (A1 = Null);
    end est_egal_null;









end arbre_binaire;
