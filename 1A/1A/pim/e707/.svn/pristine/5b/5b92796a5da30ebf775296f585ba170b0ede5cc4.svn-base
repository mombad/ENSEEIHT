with Ada.Unchecked_Deallocation;
with Ada.Text_IO;
use Ada.Text_IO;
with Ada.Integer_Text_IO;
use Ada.Integer_Text_IO;

package body Registre is
    procedure Free_Registre is
            new Ada.Unchecked_Deallocation (Object => T_Cellule_Registre, Name => T_Registre);

    procedure Free_Info is
            new Ada.Unchecked_Deallocation (Object => T_Cellule_Info, Name => T_Info);


    procedure Initialiser_R(R : out T_Registre) is
    begin
        R:=Null;
    end Initialiser_R;


    procedure Detruire_R(R:in out T_Registre) is
    begin
        if R/=null then
            Detruire_Information(R.all.Information);
            Detruire_R(R.all.suivant);
            Free_Registre(R);
        else
            null;
        end if;
    end Detruire_R;


    procedure Detruire_Information(I:in out T_Info) is
    begin
        if I/=null then
            Detruire_Information(I.all.infosuivante);
            Free_Info(I);
        else
            null;
        end if;
    end Detruire_Information;


    function Est_Vide_R(R:T_Registre) return Boolean is
    begin
        return R=Null;
    end Est_Vide_R;


    function Est_Present_R(R:in T_Registre;Cle: in Integer) return Boolean is
    begin
        if R=null then
            return False;
        else
            if R.all.Cle=Cle then
                return True;
            else
                return Est_Present_R(R.all.suivant,Cle);
            end if;
        end if;
    end Est_Present_R;


    procedure Ajouter_R_individu(R: in out T_Registre;Cle: in Integer) is
        R0: T_Registre;
    begin
        if Est_Vide_R(R) then
            R:=new T_Cellule_Registre;
            R.all.Cle:=Cle;
        else
            if Est_Present_R(R,Cle) then
                raise Est_Present_Cle;
            else
                R0:=R;
                while R0.all.suivant/=null loop
                    R0:=R0.all.suivant;
                end loop;
                R0.all.suivant:= new T_Cellule_Registre;
                R0.all.suivant.Cle:=Cle;
                R0:=null;
                Detruire_R(R0);
            end if;
        end if;
    end Ajouter_R_individu;


    procedure Ajouter_R_info(R: in out T_Registre; Cle: in Integer) is
        R0:T_Registre;
        I0:T_Info;
        Infostr: NSTR;
        Longueur:Natural;
    begin


        if Est_Present_R(R,Cle) then

            Put("Veuillez entrez une information. Par exemple 'Age : 20 ans'");
            Get_Line(Infostr,Longueur);
            if Longueur<40 then
                for i in (Longueur+1)..40 loop
                    Infostr(i):=' ';
                end loop;
            else
                null;
            end if;
            R0:=R;

            --recherche de la cellule correspondant à la clé
            while R0.all.Cle/=Cle loop
                R0:=R0.all.suivant;
            end loop;

            --si aucune information n'est renseignée
            if R0.all.Information=null then
                I0:= new T_Cellule_Info;
                I0.all.info:=Infostr;
                R0.all.Information:=I0;

            --s'il y a déja des informations renseignées
            else
                I0:=R0.all.Information;
                while I0.all.infosuivante/=null loop
                    I0:=I0.all.infosuivante;
                end loop;
                I0.all.infosuivante:= new T_Cellule_Info;
                I0.all.infosuivante.all.info:= Infostr;
                I0:=null;
                Detruire_Information(I0);
            end if;

        else
            raise Est_Absent_Cle;
        end if;
    end Ajouter_R_info;


    procedure Supprimer_R_individu(R:in out T_Registre; Cle:in Integer) is
        R0: T_Registre;
    begin
        if Est_Present_R(R,Cle) then

            if R.all.Cle=Cle then
                R0:=R;
                R:=R.all.suivant;
                Detruire_Information(R0.all.Information);
                Free_Registre(R0);

            else

                if R.all.suivant.Cle=Cle then
                    R0:=R.all.suivant;
                    R.all.suivant:=R.all.suivant.all.suivant;
                    Detruire_Information(R0.all.Information);
                    Free_Registre(R0);
                else
                    Supprimer_R_individu(R.all.suivant,Cle);
                end if;

            end if;


        else
            raise Est_Absent_Cle;
        end if;
    end Supprimer_R_individu;


    procedure Supprimer_R_information(R:in out T_Registre; Cle:in Integer) is
        R0:T_Registre;
        I0:T_Info;
        I1:T_Info;
        choix:Integer;
    begin
        if Est_Present_R(R,Cle) then

            --Recherche de la sous-liste chaînée correspondant à la clé donnée
            R0:=R;
            while R0.all.Cle/=Cle loop
                if R0=null then
                    raise Est_Absent_Cle;
                else
                    R0:=R0.all.suivant;
                end if;
            end loop;


            Afficher_info(R,Cle);
            Put("Quelle information voulez-vous supprimer ?");
            Put("Veuillez entrer le numéro correspondant à celle-ci (0 pour quitter)");
            Get(choix);

            if choix=0 then
                null;

            else

                if choix > Nb_info(R,Cle) then
                    Put("Aucune information ne correspond à ce numéro. Echec de la suppression.");

                else
                    I0:=R0.all.Information;

                    if choix=1 then
                        R0.all.Information:=R0.all.Information.all.infosuivante;
                        Free_Info(I0);


                    else


                        if choix=2 then
                            null;
                        else
                            for i in 1..(choix-2) loop
                                I0:=I0.all.infosuivante;
                            end loop;
                        end if;


                        I1:=I0.all.infosuivante;
                        if I1.all.infosuivante/=null then
                            I0.all.infosuivante:=I0.all.infosuivante.all.infosuivante;
                            Free_Info(I1);
                        else
                            Free_Info(I1);
                        end if;


                    end if;

                end if;

            end if;

        else
            raise Est_Absent_Cle;
        end if;
    end Supprimer_R_information;


    procedure Afficher_R(R:in T_Registre) is
    begin
        if R=null then
            null;
        else
            Put(R.all.Cle);
            Afficher_R(R.all.suivant);
        end if;
    end Afficher_R;


    procedure Afficher_info(R:in T_Registre;Cle:in Integer) is
        R0:T_Registre;
        I0:T_Info;
    begin
        R0:=R;
        while R0.all.Cle/=Cle loop
            R0:=R0.all.suivant;
        end loop;

        I0:=R0.all.Information;
        for i in 1..Nb_info(R,Cle) loop
            Put(I0.all.info);
            I0:=I0.all.infosuivante;
        end loop;
    end Afficher_info;


    function Nb_info(R:in T_Registre;Cle:in Integer) return Integer is
        Nb:Integer;
        R0:T_Registre;
        I0:T_Info;
    begin
        R0:=R;
        while R0.all.Cle/=Cle loop
            R0:=R0.all.suivant;
        end loop;

        Nb:=0;
        while I0/=null loop
            Nb:=+1;
            I0:=I0.all.infosuivante;
        end loop;

        return Nb;
    end Nb_info;


    function Obtenir_Nom(R:in T_Registre; Cle:in Integer) return NSTR is
        R0:T_Registre;
        I0:T_Info;
    begin
        if Est_Present_R(R,Cle) then
            R0:=R;
            while R0.all.Cle/=Cle loop
                R0:=R0.all.suivant;
            end loop;
            I0:=R0.all.Information;
            while I0.all.info(1..3)/="Nom" loop
                I0:=I0.all.infosuivante;
            end loop;
            return I0.all.info;
        else
            raise Est_Absent_Cle;
        end if;
    end Obtenir_Nom;


end Registre;
