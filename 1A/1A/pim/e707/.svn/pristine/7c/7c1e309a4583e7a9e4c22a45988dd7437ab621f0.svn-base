with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Integer_Text_IO;    use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with registre; use registre;
with lien; use lien;

package body Arbre_genealogique is

    package Arbre_genealogique is
            new Arbre_Binaire( T_Cle => Integer);
    function inferieur (Cle1: Integer; Cle2: Integer) return Boolean is
    begin
        return (Cle1 < Cle2);
    end inferieur;

    procedure Initialiser_Arbre_Gen(A : out T_Arbre_Gen;R: out T_Registre) is
    begin
        Initialiser_Arbre(A);
        Initialiser_R (R);
    end Initialiser_Arbre_Gen;

    procedure Ajouter_Arbre_Gen(A: in out T_Arbre_Gen;R: in out T_Registre; Cle_parent: in Integer ;Cle_enfant: in Integer; choix: in Boolean) is
    begin
        Ajouter(A,Cle_parent,Cle_enfant,Choix);
        Ajouter_R_individu(R,Cle_parent);
        Ajouter_R_info(R,Cle_parent);
    end Ajouter_Arbre_Gen;

    function Obtenir_nb_ancetres(A: in T_Arbre_Gen; Cle: in Integer) return Integer is
        procedure chercher_Cle(A: in T_Arbre_Gen; A1: in out T_Arbre_Gen; Cle: in Integer) is
        begin
            if A.all.Cle = Cle then --Cle trouvÃ©
                A1 := A;
            elsif A.all.Cle < Cle then
                Chercher_Cle(A.all.gauche,A1,Cle);
            elsif A.all.Cle > Cle then
                Chercher_Cle(A.all.droite,A1,Cle);
            else
                raise Est_Absent_Cle;
            end if;

        end chercher_Cle;
    begin
        declare
                    A1 : T_Arbre_Gen;
                    A2: T_Arbre_Gen;
        begin
             chercher_Noeud(A,A1,Cle);
                    if A1 = Null then
                        return 0;
                    elsif A1.all.gauche = Null and A1.all.droite = Null then
                        return 1 + Obtenir_nb_ancetres(A1.all.gauche,Cle) + Obtenir_nb_ancetres(A1.all.droite,Cle);
                    else
                        return 2 + Obtenir_nb_ancetres(A1.all.gauche,Cle) + Obtenir_nb_ancetres(A1.all.droite,Cle);
                    end if;
                end;

    end Obtenir_nb_ancetres;


    function Deux_Parents(A) return Liste is
        L:Liste;
        procedure Deux_Parents0(A:in T_Arbre_Gen;L:in out Liste) is
        begin
            if A=null then
                null;
            else
                if gauche(A)/=null and droite(A)/=null then
                    Ajouter_Liste(L,obtenir_cle(A));
                    Deux_Parents0(gauche(A);L);
                    Deux_Parents0(droite(A);L);
                end if;
            end if;
        end Deux_Parents0;
    begin
        Initialiser(L);
        Deux_Parents0(A;L);
        return L;
    end Deux_Parents;



    function Aucun_Parent(A:in T_Arbre_Gen) return Liste is
        L: Liste;
        procedure Aucun_Parent0(A:in Integer;L : in out Liste) is
        begin
            if A=null then
                null;
            else
                if gauche(A)=null and droite(A)=null then
                    Ajouter_Liste(L,Cle(A));
                    Aucun_Parent0(gauche(A),L);
                    Aucun_Parent0(droite(A),L);
                end if;
            end if;
        end Aucun_Parent0;
    begin
        Initialiser_Liste(L);
        Aucun_Parent0(A,L);
        return L;
    end Aucun_Parent;



    function Ancetres_Gen(A: in T_Arbre_Gen;Gen:in Integer)return Liste is
        Compteur: Integer;
        L: Liste;


        procedure Ancetres_Gen0(A:in T_Arbre_Gen;Gen:in Integer; L:in out Liste;Compteur:in Integer) is
        begin
            if Compteur=Gen then
                null;
            else
                if gauche(A) /=null then
                    Ajouter_Liste(L,Cle(gauche(A)));
                    Ancetres_Gen0(gauche(A));Gen;L;Compteur+1);
                else
                    null;
                end if;
                if droite(A) /=null then
                    Ajouter_Liste(L,Cle(droite(A)));
                    Ancetres_Gen0(droite(A);Gen;L;Compteur+1);
                else
                    null;
                end if;
            end if;
        end Ancetres_Gen0;

    begin

        Compteur:=0;
        Initialiser_Liste(L);
        Ancetres_Gen0(A;Gen;L;Compteur);
        return L;
    end Ancetres_Gen;

    function Homonyme(A:in T_Arbre_Gen;R:in T_Registre; n: in Integer; m: in Integer) return Boolean is
        An:T_Arbre_Gen;
        Am:T_Arbre_Gen;
        resultat: Boolean;
    begin
        An:=chercher_cle(A,n);
        Am:=chercher_cle(A,m);
    end Homonyme;


    procedure Initialiser_Liste(L: out Liste) is
    begin
        L:=null;
    end Initialiser_Liste;


    procedure Afficher_Liste(L:in Liste) is
    L0: Liste;
    begin
        L0:=Liste;
        while L0/=null loop
            Put(L0.all.Cle);
            L0:=L0.all.suivant);
        end loop;
    end Afficher_Liste;


    procedure Ajouter_Liste(L: in out Liste;Element:in Integer) is
        L0: Liste;
    begin
        if Liste=null then
            L:=new Cellule;
            L.all.Cle:=Element;
        else
            if Est_Present(L,element) then
                null;
            else
                L0:=L;
                while L0.all.Suivant/=null loop
                    L0:=L0.Suivant;
                end loop;
                L0.all.Suivant := new T_Cellule;
                L0.all.Suivant.Cle := element;
                L0:=null;
            end if;
        end if;
    end Ajouter_Liste;


    procedure Vider_Liste(L:in Liste;Element: in Integer) is
        procedure Free_Liste is new Ada.Unchecked_Deallocation (Cellule, Liste);
    begin
        if E /= Null then
            Vider_Liste(E.all.Suivant);
            Free_Liste(E);
        else
            Null;
        end if;
    end Vider_Liste;

    function Est_Present_Liste(L: in Liste; Element: in Integer) return Boolean is
















end Arbre_genealogique;


