with Arbre_genealogique;
use Arbre_genealogique;
with lien;
use lien;
with foret;
with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Integer_Text_IO;    use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with registre;
use registre;


package body foret is
   procedure initialiser_foret(F : out T_foret; A : in T_Arbre_Gen) is
   begin
      F := new cellule_A;
      F.all.A := A;
      F.all.suivant := null;
   end initialiser_foret;

   procedure Ajouter_T_Foret_Arbre(F: in out T_Foret;Element:in T_Arbre_gen; R: in out T_Registre) is
      F0 : T_Foret;
   begin
       if F=null then
            F:=new cellule_A;
            F.all.A:=Element;
        else
            if Est_Present_T_Foret_Arbre(F,element) then
                null;
            else
                F0:=F;
                while F0.all.Suivant/=null loop
                    F0:=F0.Suivant;
                end loop;
                F0.all.Suivant := new Cellule_A;
                F0.all.Suivant.A := element;
                F0:=null;
            end if;
        end if;
    end Ajouter_T_Foret_Arbre;

   procedure lier(R : in out T_Registre; A1: in T_Arbre_Gen; A2 : in T_Arbre_Gen; info : in NSTR) is
      Cle1, Cle2 : Integer;
      info1, info2 : NSTR;
   begin
      Cle1 := Obtenir_Cle(A2);
      Cle2 := Obtenir_Cle(A1);
      info1 := info & Integer'image(Cle1);
      info2 := info & Integer'image(Cle2);

      ajouter_R_info_foret(R, Cle1, info1);
      ajouter_R_info_foret(R,Cle2, info2);
   end lier;




   procedure frere( F : in T_Foret; A_enfant: in T_arbre_gen; A_frere : out T_Arbre_gen; R: in out T_Registre) is
      Cle1,Cle2 : Integer;
      info1, info2 : NSTR;
   begin

      if not Est_Present_T_Foret_Arbre(F,A_enfant) then
         raise Est_Absent_Arbre;
      else
         A_frere := A_enfant;
         Cle1 := Obtenir_Cle(A_enfant);
         Cle2 := Obtenir_Cle(A_frere);
         info1 := "frere : " & Integer'image(Cle1);
         info2 := "frere : " & Integer'image(Cle2);

         ajouter_R_info_foret(R, Cle1, info1);
         ajouter_R_info_foret(R,Cle2, info2);
      end if;
   end frere;

   procedure conjoint( F : in T_Foret ;A1 : in T_arbre_gen; A2: in T_arbre_gen; R : in out T_Registre  ) is
      Cle1, Cle2 : integer;
      noeud1, noeud2 : T_Arbre_Gen;
   begin
      if not est_Present_T_Foret_Arbre(F,A1) and not Est_Present_T_Foret_Arbre(F,A2) then
         raise est_absent_arbre;
      else
         Put("choisir un élément de l'arbre 1 : ");
         get(Cle1);
         Put("choisir un élément de l'arbre 1 : ");
         get(Cle2);
         chercher_noeud(A1,noeud1,Cle1);
         chercher_noeud(A2,noeud2,Cle2);
         lier(R,A1,A2,"conjoint :                                   ");
      end if;
   end conjoint;

   function obtenir_conjoint_foret(F : in T_Foret; A1 : in T_Arbre_Gen; R : in out T_Registre) return T_Liste is
        An:T_Arbre_Gen;
        resultat: T_Liste;
        L,Ln : T_Liste;
        F0 : T_Foret;

        Ln0,Ln1 : T_Liste;




    begin

        Initialiser_Liste(Ln);
      egal_liste(Ln,L);
      F0 := F;
        while F/= null loop
            Obtenir_Tous_Les_Ancetres(F.all.A,L);
            F0 := F0.all.suivant;
        end loop;

        Initialiser_Liste(resultat);
       for i in 1..Longueur_Liste(Ln) loop
            egal_liste(Ln1,L);
                if Obtenir_conjoint(R,obtenir_element(Ln1))/="Le nom de cet individu n'est pas renseigné  " then
                    if Obtenir_conjoint(R,obtenir_element(Ln1)) = Integer'Image(Obtenir_cle(A1)) then
                        Ajouter_Liste(resultat,obtenir_element(Ln1));
                    else
                        null;
                    end if;
                else
                    null;
                end if;
            egal_liste(Ln1,obtenir_suivant_liste(Ln1));
        end loop;
        return resultat;
   end obtenir_conjoint_foret;


   function obtenir_frere_foret(F : in T_Foret; A1 : in T_Arbre_Gen; R : in out T_Registre) return T_Liste is
        An:T_Arbre_Gen;
        resultat: T_Liste;
        L,Ln : Liste;
        F0 : T_Foret;

        Ln0,Ln1 : Liste;




    begin

       Initialiser_Liste(Ln);
      egal_liste(Ln,L);
      F0 := F;
        while F/= null loop
            Obtenir_Tous_Les_Ancetres(F.all.A,L);
            F0 := F0.all.suivant;
        end loop;

        Initialiser_Liste(resultat);
       for i in 1..Longueur_Liste(Ln) loop
            egal_liste(Ln1,L);
                if Obtenir_frere(R,obtenir_element(Ln1))/="Le nom de cet individu n'est pas renseigné  " then
                    if Obtenir_frere(R,obtenir_element(Ln1)) = Integer'Image(Obtenir_cle(A1)) then
                        Ajouter_Liste(resultat,obtenir_element(Ln1));
                    else
                        null;
                    end if;
                else
                    null;
                end if;
            egal_liste(Ln1,obtenir_suivant_liste(Ln1));
        end loop;
        return resultat;
   end obtenir_frere_foret;

   function obtenir_beau_frere(F : in T_foret; A1 : in T_Arbre_Gen; R : in out T_Registre) return T_Liste is
      Lc,Liste_conjoint : Liste;
      Lf,Liste_frere : Liste;
      Liste_beau_frere : Liste;

   begin
      Liste_frere := obtenir_frere_foret(F , A1, R);
      Liste_conjoint := obtenir_frere_foret(F , A1, R);
      Lc := Liste_conjoint;
      Lf := Liste_frere;

      while not est_vide_liste(Lc) loop
         while not est_vide_liste(Lf) loop
            if obtenir_element(Lf) = obtenir_element(Lc) then
               Ajouter_Liste(Liste_beau_frere,obtenir_element(Lc));
            else
               null;
            end if;
            egal_liste(Lf,obtenir_suivant_liste(Lf));
         end loop;
         egal_liste(Lc,obtenir_suivant_liste(Lc));
      end loop;
      return Liste_beau_frere;
   end obtenir_beau_frere;


function Est_Present_T_Foret_Arbre(F: in T_Foret; Element: in T_Arbre_gen) return Boolean is
   F0: T_foret;
   resultat: Boolean;
begin
   F0:=F;
   resultat:=False;
   while F0/=null loop
   if F0.A=Element then
        resultat:=True;
   else
        null;
   end if;
        F0:=F0.suivant;
   end loop;
   return resultat;
end Est_Present_T_Foret_Arbre;

   procedure afficher_Foret(F : in T_foret) is
      F0 : T_Foret;
      A1 : T_Arbre_Gen;
   begin
      if F=null then
            Put("La foret est vide");
        else
            null;
        end if;
        F0:=F;
        while F0/=null loop
            A1 := F0.all.A;
            Put(Obtenir_Cle(A1));
            F0:=F0.all.suivant;
        end loop;
   end afficher_Foret;

   procedure Vider_T_Foret_Arbre(F:in out T_Foret;Element: in T_Arbre_gen) is
      procedure Free_Foret is new Ada.Unchecked_Deallocation (Cellule_A, T_Foret);
   begin
      if F /= Null then
            Vider_T_Foret_Arbre(F.all.Suivant,Element);
            Free_Foret(F);
        else
            Null;
      end if;
   end Vider_T_Foret_Arbre;


end foret;

























