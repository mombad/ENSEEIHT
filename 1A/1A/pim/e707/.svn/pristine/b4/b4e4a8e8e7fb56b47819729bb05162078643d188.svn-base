with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Integer_Text_IO;    use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with registre; use registre;
with lien; use lien;
with piles;


package body Arbre_genealogique is



    procedure Initialiser_Arbre_Gen(A : out T_Arbre_Gen;R: out T_Registre) is
    begin
        Initialiser_Arbre(A);
        Initialiser_R (R);
    end Initialiser_Arbre_Gen;





    procedure Ajouter_Arbre_Gen(A: in out T_Arbre_Gen;R: in out T_Registre; Cle_parent: in Integer ;Cle_enfant: in Integer; choix: in Boolean) is
    begin
        Ajouter(A,Cle_parent,Cle_enfant,Choix);
        Ajouter_R_individu(R,Cle_parent);
        Ajouter_R_info(R,Cle_parent);
    end Ajouter_Arbre_Gen;







     function Obtenir_nb_ancetres(A: in T_Arbre_Gen; Cle: in Integer) return Integer is
        A1 : T_Arbre_Gen;
        P: T_Pile;
        A2 : T_Arbre_Gen;
        nb : Integer;
    begin

        chercher_Ccherle(A,A1,Cle);
        A2 :=A1;
        initialiser(P);
        empiler(P,A1);
        nb := 1;
      while not est_vide(P) loop
         A2 := sommet(P);
         depiler(P);
         if A2.all.droite /= null then
           empiler(P,A2.all.droite);
           nb:= nb+1;
         else
            null;
         end if;

         if A2.all.gauche /= null then
           empiler(P,A2.all.gauche);
           nb:=nb+1;
         else
            null;
         end if;
      end loop;
      return nb;
      end Obtenir_nb_ancetres;




    function Obtenir_nb_ancetres_Gen(A : in T_Arbre_Gen; Cle: in Integer; Gen : in Integer) return Liste is
            A1:  T_Arbre_Gen;
            i : Integer;
            L: Liste;
            p : Piles;

      begin
            initialiser_liste(L);
            chercher_noeud(A,A1,Cle);
            empiler(P,A.all.gauche);
            A1 := sommet(P);
            while not est_vide(P) loop
            for i in 1..gen do
                A1 := A1.all.gauche;
                ajouter_liste(L,A1.all.Cle);
            end loop;

            depiler(P);
            if A1.all.droite /= null then
                empiler(P,A1.all.droite);
            else
                null;
            end if;
            return L;
       end Obtenir_nb_ancetres_gen;






    function Un_parent(A: in T_Arbre_gen) is
     A1 : T_Arbre_gen;
     P : T_Piles;
     L : Liste;
     begin
        A1 :=A;
        initialiser(P);
        empiler(P,A);
      while not est_vide(P) loop
         A1 := sommet(P);
         depiler(P);
         if A1.all.droite /= null then
           empiler(P,A1.all.droite);
           if A1.all.gauche /= null then
                ajouter_Liste(Liste, A1.all.Cle);
           else
                null;
           end if;
         else
            null;
         end if;

         if A1.all.gauche /= null then
           empiler(P,A1.all.gauche);
           if A1.all.droite /= null then
                ajouter_Liste(liste, A1.all.Cle);
           else
                null;
           end if;
         else
            null;
         end if;
      end loop;
      return L;

    function Deux_Parents(A:in T_Arbre_Gen) return Liste is
        L:Liste;
        procedure Deux_Parents0(A:in T_Arbre_Gen;L:in out Liste) is
        begin
            if A=null then
                null;
            else
                if gauche(A)/=null and droite(A)/=null then
                    Ajouter_Liste(L,obtenir_cle(A));
                    Deux_Parents0(gauche(A),L);
                    Deux_Parents0(droite(A),L);
                end if;
            end if;
        end Deux_Parents0;
    begin
        Initialiser_Liste(L);
        Deux_Parents0(A,L);
        return L;
    end Deux_Parents;



    function Aucun_Parent(A:in T_Arbre_Gen) return Liste is
        L: Liste;
        procedure Aucun_Parent0(A:in Integer;L : in out Liste) is
        begin
            if A=null then
                null;
            else
                if gauche(A)=null and droite(A)=null then
                    Ajouter_Liste(L,obtenir_cle(A));
                    Aucun_Parent0(gauche(A),L);
                    Aucun_Parent0(droite(A),L);
                end if;
            end if;
        end Aucun_Parent0;
    begin
        Initialiser_Liste(L);
        Aucun_Parent0(A,L);
        return L;
    end Aucun_Parent;



    function Ancetres_Gen(A: in T_Arbre_Gen;Gen:in Integer)return Liste is
        Compteur: Integer;
        L: Liste;


        procedure Ancetres_Gen0(A:in T_Arbre_Gen;Gen:in Integer; L:in out Liste;Compteur:in Integer) is
        begin
            if Compteur=Gen then
                null;
            else
                if gauche(A) /=null then
                    Ajouter_Liste(L,obtenir_cle(gauche(A)));
                    Ancetres_Gen0(gauche(A)),Gen,L,Compteur+1);
                else
                    null;
                end if;
                if droite(A) /=null then
                    Ajouter_Liste(L,Cle(droite(A)));
                    Ancetres_Gen0(droite(A),Gen,L,Compteur+1);
                else
                    null;
                end if;
            end if;
        end Ancetres_Gen0;

    begin

        Compteur:=0;
        Initialiser_Liste(L);
        Ancetres_Gen0(A,Gen,L,Compteur);
        return L;
    end Ancetres_Gen;

    function Homonyme(A:in T_Arbre_Gen;R:in T_Registre; n: in Integer; m: in Integer) return Liste is
        An:T_Arbre_Gen;
        Am:T_Arbre_Gen;
        resultat: Liste;
        Ln : Liste;
        Lm : Liste;

        Ln0 : Liste;
        Lm0: Liste;


        procedure Obtenir_Tous_Les_Ancetres(A : in T_Arbre_Gen ; L : in out Liste) is
        begin
            if gauche(A)=null then
                null;
            else
                Ajouter_Liste(L,Obtenir_Cle(gauche(A)));
            end if;

            if droite(A)=null then
                null;
            else
                Ajouter_Liste(L,Obtenir_Cle(droite(A)));
            end if;
            Obtenir_Tous_Les_Ancetres(gauche(A),L);
            Obtenir_Tous_Les_Ancetres(droite(A),L);
        end Obtenir_Tous_Les_Ancetres;


    begin
        Initialiser_Arbre_Gen(An);
        chercher_noeud(A,An,n);
        Initialiser_Arbre_Gen(Am);
        chercher_noeud(A,Am,m);

        Initialiser_Liste(Ln);
        Initialiser_Liste(Lm);

        Obtenir_Tous_Les_Ancetres(A,Ln);
        Obtenir_Tous_Les_Ancetres(A,Lm);

        Initialiser_Liste(resultat);
        Ln0:=Ln;
        for i in Longueur_Liste(Ln) loop
            Lm0:=Lm;
            for j Longueur_Liste(Lm) loop
                if Obtenir_nom(Ln0.Cle)=Obtenir_Nom(Lm0.Cle) then
                    Ajouter_Liste(resultat,Ln0.Cle);
                    Ajouter_Liste(resultat,Lm0.Cle);
                else
                    null;
                end if;
                Lm0:=Lm.suivant;
            end loop;
            Ln0:=Ln.suivant;
        end loop;
        return resultat;
    end Homonyme;


    function Est_Present_Gen(A:in T_Arbre_Gen;Cle:in Integer) return Boolean is
    begin
        return Est_Present(A,Cle);
    end Est_Present_Gen;















    --Manipulation des listes
    procedure Initialiser_Liste(L: out Liste) is
    begin
        L:=null;
    end Initialiser_Liste;


    procedure Afficher_Liste(L:in Liste) is
    L0: Liste;
    begin
        L0:=Liste;
        while L0/=null loop
            Put(L0.all.Cle);
            L0:=L0.all.suivant;
        end loop;
    end Afficher_Liste;


    procedure Ajouter_Liste(L: in out Liste;Element:in Integer) is
        L0: Liste;
    begin
        if Liste=null then
            L:=new Cellule;
            L.all.Cle:=Element;
        else
            if Est_Present(L,element) then
                null;
            else
                L0:=L;
                while L0.all.Suivant/=null loop
                    L0:=L0.Suivant;
                end loop;
                L0.all.Suivant := new T_Cellule;
                L0.all.Suivant.Cle := element;
                L0:=null;
            end if;
        end if;
    end Ajouter_Liste;


    procedure Vider_Liste(L:in Liste;Element: in Integer) is
        procedure Free_Liste is new Ada.Unchecked_Deallocation (Cellule, Liste);
    begin
        if E /= Null then
            Vider_Liste(E.all.Suivant);
            Free_Liste(E);
        else
            Null;
        end if;
    end Vider_Liste;

    function Est_Present_Liste(L: in Liste; Element: in Integer) return Boolean is
        L0:Liste;
        resultat: Boolean;
    begin
        L0:=L;
        resultat:=False;
        while L0/=null loop
            if L0.Cle=Element then
                resultat:=True;
            else
                null;
            end if;
            L0:=L0.suivant;
        end loop;
        return resultat;
    end Est_Present_Liste;


    function Longueur_Liste(L:in Liste) return Integer is
        n : Integer;
        L0: Liste;
    begin
        L0:=L;
        n:=0;
        while L0/=null loop
            n:=n+1;
            L0:=L0.all.suivant;
        end loop;
        return n;
    end Longueur_Liste;





end Arbre_genealogique;


